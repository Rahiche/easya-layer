import { Balance, BlockchainProvider, CurrencyTransactionConfig, NFT, NFTConfig, TokenConfig, TokenIssuanceData, TokenIssuanceResult, TransactionConfig, TransactionResult, TrustLineConfig, WalletInfo } from "../../core/types";
import { Client } from "xrpl";
import { XRPLUtils } from "./XRPLUtils";
export declare class XRPLProvider implements BlockchainProvider {
    private walletAdapter;
    private walletInfo;
    private connection;
    private readonly network;
    private static readonly NETWORKS;
    constructor(walletName: string, network: string);
    xrplUtils(): XRPLUtils;
    issueToken(config: TokenIssuanceData): Promise<TransactionResult>;
    isWalletInstalled(): Promise<boolean>;
    getBalance(address?: string): Promise<number>;
    connect(): Promise<string>;
    establishConnection(): Promise<Client>;
    disconnect(): Promise<void>;
    sendTransaction(config: TransactionConfig): Promise<TransactionResult>;
    mintNFT(config: NFTConfig): Promise<TransactionResult>;
    issueFungibleToken(config: TokenConfig): Promise<TokenIssuanceResult>;
    transferNFT(tokenId: string, to: string): Promise<TransactionResult>;
    mintToken(config: TokenConfig): Promise<TransactionResult>;
    getNFTs(address?: string): Promise<Array<NFT>>;
    private fetchNFTMetadata;
    getTransactionStatus(hash: string): Promise<TransactionResult>;
    getWalletInfo(): Promise<WalletInfo>;
    estimateFee(config: TransactionConfig): Promise<string>;
    sendCurrency(config: CurrencyTransactionConfig): Promise<TransactionResult>;
    createTrustLine(config: TrustLineConfig): Promise<TransactionResult>;
    getBalances(address?: string): Promise<Balance[]>;
    validateAddress(address: string): boolean;
    getTokenBalance(tokenId: string, address?: string): Promise<string>;
    getNFTMetadata(tokenId: string): Promise<Record<string, any>>;
    isConnected(): boolean;
    transferToken(config: TransactionConfig): Promise<TransactionResult>;
    getNetwork(): string;
    getBlockHeight(): Promise<number>;
    sign(message: string): Promise<string>;
    verify(message: string, signature: string, address: string): Promise<boolean>;
    subscribeToEvents(eventName: string, callback: (data: any) => void): void;
    unsubscribeFromEvents(eventName: string): void;
}
